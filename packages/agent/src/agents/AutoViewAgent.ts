import {
  IAutoViewCompilerMetadata,
  IAutoViewComponentProps,
} from "@autoview/interface";
import { type ILlmSchema, OpenApiTypeChecker } from "@samchon/openapi";
import typia, { type IJsonSchemaUnit } from "typia";

import { AllInOne, CodeGeneration, PlanGeneration } from "../passes";
import { IAutoViewVendor } from "../structures";
import { type ConvertedSchema, convertSchema } from "./convert-schema";

export interface IAutoViewInputSchemaBase<T extends string> {
  type: T;
}

export interface IAutoViewJsonSchemaInput
  extends IAutoViewInputSchemaBase<"json-schema"> {
  unit: IJsonSchemaUnit;
}

export interface IAutoViewLlmSchemaInput<Model extends ILlmSchema.Model>
  extends IAutoViewInputSchemaBase<"llm-schema"> {
  model: Model;
  schema: ILlmSchema.ModelSchema[Model];
  $defs?: Record<string, ILlmSchema.ModelSchema[Model]>;
}

export interface IAutoViewParametersInput<Model extends ILlmSchema.Model>
  extends IAutoViewInputSchemaBase<"parameters"> {
  model: Model;
  parameters: ILlmSchema.ModelParameters[Model];
}

export type IAutoViewInput =
  | IAutoViewJsonSchemaInput
  | IAutoViewLlmSchemaInput<"chatgpt">
  | IAutoViewLlmSchemaInput<"claude">
  | IAutoViewLlmSchemaInput<"gemini">
  | IAutoViewLlmSchemaInput<"llama">
  | IAutoViewLlmSchemaInput<"3.0">
  | IAutoViewLlmSchemaInput<"3.1">
  | IAutoViewParametersInput<"chatgpt">
  | IAutoViewParametersInput<"claude">
  | IAutoViewParametersInput<"gemini">
  | IAutoViewParametersInput<"llama">
  | IAutoViewParametersInput<"3.0">
  | IAutoViewParametersInput<"3.1">;

/**
 * Configuration of the {@link AutoViewAgent}.
 */
export interface IAutoViewConfig {
  /**
   * The vendor of the entire agent pipeline.
   */
  vendor: IAutoViewVendor;

  /**
   * The vendor of the code generation.
   *
   * If not provided, the same vendor as the `vendor` will be used.
   */
  codeVendor?: IAutoViewVendor;

  /**
   * The input schema to be transformed.
   */
  input: IAutoViewInput;

  /**
   * The name of the transform function generated by the agent.
   *
   * Give different names if you plan to generate multiple transform functions to prevent name conflicts.
   *
   * If not provided, the default name will be `transform`.
   *
   * @default "transform"
   */
  transformFunctionName?: string;

  /**
   * Whether to use the experimental all-in-one agent, instead of the default pipeline.
   *
   * @default false
   */
  experimentalAllInOne?: boolean;
}

/**
 * Result of the {@link AutoViewAgent}.
 */
export interface IAutoViewResult {
  /**
   * The TypeScript code of the transform function.
   *
   * This code includes several import statements, preventing it to include bunch of DTO interface declarations.
   */
  transformTsCode: string;
}

/**
 * The `AutoViewAgent`.
 *
 * This is the class that orchestrates the entire agent pipeline.
 */
export class AutoViewAgent {
  constructor(private config: IAutoViewConfig) {}

  /**
   * Execute the agent pipeline.
   *
   * It generates the TypeScript code of the transform function from the input schema into the AutoView component.
   *
   * @returns The result of the agent pipeline.
   */
  async generate(): Promise<IAutoViewResult> {
    if (this.config.experimentalAllInOne) {
      return this.generateWithAllInOne();
    } else {
      return this.generateWithPlanGeneration();
    }
  }

  private getInputSchema(): IAutoViewCompilerMetadata {
    if (this.config.input.type === "json-schema") {
      return {
        components: this.config.input.unit.components ?? {},
        schema: this.config.input.unit.schema,
      } satisfies IAutoViewCompilerMetadata;
    } else if (this.config.input.type === "llm-schema") {
      let converted: ConvertedSchema;

      switch (this.config.input.model) {
        case "chatgpt": {
          converted = convertSchema<"chatgpt">(
            "chatgpt",
            this.config.input.schema,
            this.config.input.$defs,
          );
          break;
        }
        case "claude": {
          converted = convertSchema<"claude">(
            "claude",
            this.config.input.schema,
            this.config.input.$defs,
          );
          break;
        }
        case "gemini": {
          converted = convertSchema<"gemini">(
            "gemini",
            this.config.input.schema,
            this.config.input.$defs,
          );
          break;
        }
        case "llama": {
          converted = convertSchema<"llama">(
            "llama",
            this.config.input.schema,
            this.config.input.$defs,
          );
          break;
        }
        case "3.0": {
          converted = convertSchema<"3.0">(
            "3.0",
            this.config.input.schema,
            this.config.input.$defs,
          );
          break;
        }
        case "3.1": {
          converted = convertSchema<"3.1">(
            "3.1",
            this.config.input.schema,
            this.config.input.$defs,
          );
          break;
        }
      }
      return {
        components: converted.components,
        schema: converted.schema,
      } satisfies IAutoViewCompilerMetadata;
    } else if (this.config.input.type === "parameters") {
      let converted: ConvertedSchema;

      switch (this.config.input.model) {
        case "chatgpt": {
          converted = convertSchema<"chatgpt">(
            "chatgpt",
            this.config.input.parameters,
            this.config.input.parameters.$defs,
          );
          break;
        }
        case "claude": {
          converted = convertSchema<"claude">(
            "claude",
            this.config.input.parameters,
            this.config.input.parameters.$defs,
          );
          break;
        }
        case "gemini": {
          converted = convertSchema<"gemini">(
            "gemini",
            this.config.input.parameters,
          );
          break;
        }
        case "llama": {
          converted = convertSchema<"llama">(
            "llama",
            this.config.input.parameters,
            this.config.input.parameters.$defs,
          );
          break;
        }
        case "3.0": {
          converted = convertSchema<"3.0">("3.0", this.config.input.parameters);
          break;
        }
        case "3.1": {
          converted = convertSchema<"3.1">(
            "3.1",
            this.config.input.parameters,
            this.config.input.parameters.$defs,
          );
          break;
        }
      }
      return {
        components: converted.components,
        schema: converted.schema,
      } satisfies IAutoViewCompilerMetadata;
    } else {
      throw new Error("invalid input schema type");
    }
  }

  private async generateWithPlanGeneration(): Promise<IAutoViewResult> {
    const inputSchema = this.getInputSchema();

    const planGenerationAgent = new PlanGeneration.Agent();
    await planGenerationAgent.open();

    const codeGenerationAgent = new CodeGeneration.Agent();
    await codeGenerationAgent.open();

    try {
      const components = componentSchema();
      const plan = await planGenerationAgent.execute({
        vendor: this.config.vendor,
        inputSchema,
        componentSchema: components,
      });
      const { transformTsCode } = await codeGenerationAgent.execute({
        vendor: this.config.codeVendor ?? this.config.vendor,
        inputSchema,
        componentSchema: components,
        initialAnalysis: plan.initial_analysis,
        dataExploration: plan.data_exploration,
        ideas: plan.ideas,
        reasoning: plan.reasoning,
        planning: plan.planning,
        transformFunctionName: this.config.transformFunctionName ?? "transform",
      });

      return {
        transformTsCode,
      };
    } finally {
      try {
        await planGenerationAgent.close();
      } catch (error) {
        console.warn(`failed to close plan generation agent: ${error}`);
      }
      try {
        await codeGenerationAgent.close();
      } catch (error) {
        console.warn(`failed to close code generation agent: ${error}`);
      }
    }
  }

  private async generateWithAllInOne(): Promise<IAutoViewResult> {
    const inputSchema = this.getInputSchema();

    const allInOneAgent = new AllInOne.Agent();
    await allInOneAgent.open();

    try {
      const components = componentSchema();
      const result = await allInOneAgent.execute({
        vendor: this.config.vendor,
        inputSchema,
        componentSchema: components,
        transformFunctionName: this.config.transformFunctionName ?? "transform",
      });

      return {
        transformTsCode: result.transformTsCode,
      };
    } finally {
      try {
        await allInOneAgent.close();
      } catch (error) {
        console.warn(`failed to close all-in-one agent: ${error}`);
      }
    }
  }
}

function componentSchema(): IAutoViewCompilerMetadata {
  if (!OpenApiTypeChecker.isObject(PARAMETERS)) {
    throw new Error("PARAMETERS is not an object.");
  }

  return {
    $defs: PARAMETERS.$defs,
    schema: PARAMETERS.properties["props"]!,
  };
}

const PARAMETERS = typia.llm.parameters<
  {
    props: IAutoViewComponentProps;
  },
  "chatgpt",
  {
    reference: true;
  }
>();
